<!DOCTYPE html>
<html lang="en">

	<head>
		<title>dent_tis</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/static/css/info.css"/>
		<div id="result"></div>
	</head>

	<body>

		<div class="dent" id="container"></div>
		<!-- load javascript libraries and functions we're going to need -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
		<script src="{{url_for('static', filename='./build/three.js')}}"></script>
    <script src="{{url_for('static', filename='./js/WebGL.js')}}"></script>

		<script src="{{url_for('static', filename='./js/controls/DeviceOrientationControls.js')}}"></script>

		<script src="{{url_for('static', filename='./js/loaders/RGBELoader.js')}}"></script>
		<script src="{{url_for('static', filename='./js/loaders/HDRCubeTextureLoader.js')}}"></script>

		<script src="{{url_for('static', filename='./js/pmrem/PMREMGenerator.js')}}"></script>
		<script src="{{url_for('static', filename='./js/pmrem/PMREMCubeUVPacker.js')}}"></script>
		<script src="{{url_for('static', filename='./js/geometries/ParametricGeometries.js')}}"></script>
		<script>

			// make sure webGL is available
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
				}

			// define some global variables
			var container;
			var camera, scene, renderer, controls;
			var CubeRenderTarget, CubeMap;
     test_angles = {{ test_angles }};
     var values = JSON.parse('{{ values | safe}}');
     console.log(values);
     var value_counter = 0;
     var previous_x = 0;
     var previous_y = 0;
     var previous_z = 0;

			// do stuff
			init();
			animate();


			function init() {

				// create a container for the graphics content
				container = document.createElement('div');
				document.body.appendChild(container);

				// create a renderer for the graphics content
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.gammaOutput = true;
 				container.appendChild(renderer.domElement); // attach the renderer to the container

				// create a new graphics scene
				scene = new THREE.Scene();

				// load a HDR cubemap to serve as the scene background and object illumination map
				var Urls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				CubeMap = new THREE.HDRCubeTextureLoader()
//					.setPath( '/static/textures/envs/ennis_512/' )
					.setPath( '/static/textures/envs/artist_workshop_1024/' )
					.load( THREE.UnsignedByteType, Urls, function() {

						var pmremGenerator = new THREE.PMREMGenerator(CubeMap);
						pmremGenerator.update(renderer);

						var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
						pmremCubeUVPacker.update(renderer);

						CubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;

						CubeMap.magFilter = THREE.LinearFilter;
						CubeMap.needsUpdate = true;

						pmremGenerator.dispose();
						pmremCubeUVPacker.dispose();

						});
				scene.background = CubeMap;

				// create the dent object
				var xsize = 512;
				var ysize = 512;

				var meshFunc = function(u,v,target) {
					var r = Math.random(); // may need this someday
   					x = xsize * u; // size of plane in x,y
   					y = ysize * v;
					//u0 = 0.8; // location of dent
					  //v0 = 0.8;
            u0 = {{ uv_dict["u"] }};
            v0 = {{ uv_dict["v"] }};
					usig = 0.025; // width of dent
					vsig = 0.025;
					//disp = -1.0; // depth/height of dent
            disp = {{ uv_dict["disp"] }};
					uterm = Math.pow(u-u0,2)/Math.pow(2*usig,2); // make the gaussian dent
					vterm = Math.pow(v-v0,2)/Math.pow(2*vsig,2);
					z = disp*Math.exp(-(uterm+vterm));
   					target.set(x,y,z); // return the vals to create the geometry
  					};

 				var geometry = new THREE.ParametricBufferGeometry(meshFunc, xsize, ysize);
 				geometry.center(); // plane x,y's start at 0 so center in worldspace

// bronze03_green
				var material = new THREE.MeshStandardMaterial({
// 					map: new THREE.TextureLoader().load('./objects/bronze03/diff.png'),
				 	color: new THREE.Color("rgb(10%, 30%, 10%)"),
					metalness: 0.5,
//					metalnessMap: new THREE.TextureLoader().load('./objects/bronze03/spec.png'),
					roughness: 0.33,
//					roughnessMap: new THREE.TextureLoader().load('./objects/bronze03/rough.png'),
//					displacementMap: new THREE.TextureLoader().load('./objects/bronze03/disp.png'),
					normalMap: new THREE.TextureLoader().load('/static/textures/objects/bronze03/norm.png'),
					normalScale: new THREE.Vector3( 0.5, 0.5 ),
					side: THREE.DoubleSide
					});

				objMesh = new THREE.Mesh(geometry, material);
				scene.add(objMesh);


				// add a camera to the scene
				camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 1, 3000);
				camera.position.set(0,0,1000);
 				camera.lookAt(0,0,0);

				// lock the object and camera together
 				//objMesh.add(camera);

				// add accelerometer controls to the object/camera group
				//controls = new THREE.DeviceOrientationControls(objMesh);

				// add a listener to handle window resizing
				window.addEventListener( 'resize', onWindowResize, false );

			}

     function degToRad(angle){

         return (angle * Math.PI/180);
     }

			// animation loop
		 function animate() {
         setTimeout(function(){
				requestAnimationFrame(animate);
        //objMesh.rotation.x += test_angles[value_counter] ;
        //console.log('angles - ' + test_angles[value_counter]);
        if (value_counter == 0){
            previous_z = degToRad(values[0]["alpha"]);
            previous_x = degToRad(values[0]["beta"]);
            previous_y = degToRad(values[0]["gamma"]);
            objMesh.rotation.x += Math.PI/2 ;
            objMesh.rotation.z += previous_z;
            objMesh.rotation.x += previous_x;
            objMesh.rotation.y += previous_y;
            //console.log(previous_x, previous_y, previous_z );
            //objMesh.rotation.z = values[value_counter]["alpha"];

        }
        else{
            objMesh.rotation.z += (degToRad(values[value_counter]["alpha"]) - previous_z);
            objMesh.rotation.x += (degToRad(values[value_counter]["beta"]) - previous_x) ;
            objMesh.rotation.y += (degToRad(values[value_counter]["gamma"]) - previous_y);
            console.log((degToRad(values[value_counter]["alpha"]) - previous_z),(degToRad(values[value_counter]["beta"]) - previous_x),(degToRad(values[value_counter]["gamma"]) - previous_y) )
            //objMesh.rotation.z = values[value_counter]["alpha"];
            //rotX = (values[value_counter]["beta"] - previous_x)
            //if (rotX > 0)
                {
                    //objMesh.rotation.x = rotX ;
                    //objMesh.rotation.x += 0.05;
                    //console.log(rotX)
                }
            //objMesh.rotation.y = values[value_counter]["gamma"];
            previous_z = degToRad(values[value_counter]["alpha"]);
            previous_x = degToRad(values[value_counter]["beta"]);
            previous_y = degToRad(values[value_counter]["gamma"]);}

				render();
        value_counter++;
        if (value_counter >= values.length){
            //value_counter = 0;
        }
        }, 100);
				}


			// scene renderer
			function render() {
				var renderTarget, newEnvMap;

				// update the object env map if necessary
				renderTarget = CubeRenderTarget;
				newEnvMap = renderTarget ? renderTarget.texture : null;
				if ( newEnvMap && newEnvMap !== objMesh.material.envMap ) {
					objMesh.material.envMap = newEnvMap;
					objMesh.material.needsUpdate = true;
					}

				// render the scene
				renderer.render(scene, camera);
				}


			// window resize handler
			function onWindowResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				camera.aspect = width/height;
				camera.updateProjectionMatrix();
				renderer.setSize(width, height);
				}

    </script>

	</body>
</html>
