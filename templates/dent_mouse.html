<!DOCTYPE html>
<!--
manuscript viewer w/ object controls
(controls hacked from https://threejs.org/examples/#misc_controls_transform)
jaf - 5/5/19, created
11/10/19 - jaf - hacked for vss expt

 -->

<html lang="en">
	<head>
		<title>dent_mouse</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link rel="stylesheet" type="text/css" href="/static/css/info.css"/>
    <div id="result"></div>
	</head>
	<body>

		<div class="dent" id="container"></div>
		<!-- load javascript libraries and functions we're going to need -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
		<script src="{{url_for('static', filename='./build/three.js')}}"></script>
    <script src="{{url_for('static', filename='./js/WebGL.js')}}"></script>

		<script src="{{url_for('static', filename='./js/controls/OrbitControls.js')}}"></script>
		<script src="{{url_for('static', filename='./js/controls/TransformControls.js')}}"></script>

		<script src="{{url_for('static', filename='./js/loaders/RGBELoader.js')}}"></script>
		<script src="{{url_for('static', filename='./js/loaders/HDRCubeTextureLoader.js')}}"></script>

		<script src="{{url_for('static', filename='./js/pmrem/PMREMGenerator.js')}}"></script>
		<script src="{{url_for('static', filename='./js/pmrem/PMREMCubeUVPacker.js')}}"></script>
		<script src="{{url_for('static', filename='./js/geometries/ParametricGeometries.js')}}"></script>
    <div class="done" id="done_button">
        <button type="button">I'm done!</button>
    </div>
		<script>

			// make sure webGL is available
			if ( WEBGL.isWebGLAvailable() === false ) {
				document.body.appendChild( WEBGL.getWebGLErrorMessage() );
				}

			// define some global variables
			var container;
			var camera, scene, renderer, control, orbit;
			var hdrCubeRenderTarget, hdrCubeMap;

      var values =[];
			init();
			animate();

			function init() {

				// create a container for the graphics content
				container = document.createElement('div');
				document.body.appendChild(container);

				// create a renderer for the graphics content
				renderer = new THREE.WebGLRenderer();
				renderer.setSize(window.innerWidth, window.innerHeight);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.toneMapping = THREE.ReinhardToneMapping;
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				// attach the renderer to the container
				container.appendChild(renderer.domElement);

				// create a scene
				scene = new THREE.Scene();

				// load a HDR cubemap to serve as the scene background and object illumination map
				var hdrUrls = [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ];
				hdrCubeMap = new THREE.HDRCubeTextureLoader()
            .setPath( '/static/textures/envs/ennis/' )
					.load( THREE.UnsignedByteType, hdrUrls, function() {

						var pmremGenerator = new THREE.PMREMGenerator(hdrCubeMap);
						pmremGenerator.update(renderer);

						var pmremCubeUVPacker = new THREE.PMREMCubeUVPacker(pmremGenerator.cubeLods);
						pmremCubeUVPacker.update(renderer);

						hdrCubeRenderTarget = pmremCubeUVPacker.CubeUVRenderTarget;

						hdrCubeMap.magFilter = THREE.LinearFilter;
						hdrCubeMap.needsUpdate = true;

						pmremGenerator.dispose();
						pmremCubeUVPacker.dispose();

						});

				// set the cubemap as the scene background
				scene.background = hdrCubeMap;

				// create and add the object to the scene
				var xsize = 512;
				var ysize = 512;

				var meshFunc = function(u,v,target) {
					var r = Math.random(); // may need this someday
   					x = xsize * u; // size of plane in x,y
   					y = ysize * v;
					u0 = 0.7; // location of dent
					v0 = 0.7;
					usig = 0.05; // width of dent
					vsig = 0.05;
					disp = -2.5; // depth/height of dent
					uterm = Math.pow(u-u0,2)/Math.pow(2*usig,2); // make the gaussian dent
					vterm = Math.pow(v-v0,2)/Math.pow(2*vsig,2);
					z = disp*Math.exp(-(uterm+vterm));
   					target.set(x,y,z); // return the vals to create the geometry
  					};

  				var geometry = new THREE.ParametricBufferGeometry(meshFunc, xsize, ysize);
  				geometry.center(); // plane x,y's start at 0 so center in worldspace
//   				geometry.rotateZ(Math.PI);
//   				geometry.rotateX(-Math.PI/2);



				var material = new THREE.MeshStandardMaterial({
					side: THREE.DoubleSide,
					color: new THREE.Color("rgb(10%, 30%, 10%)"),
					roughness: 0.5
					});

				objMesh = new THREE.Mesh(geometry, material);
// 				objMesh.lookAt(new THREE.Vector3(0,0,1));

				scene.add(objMesh);


				// camera
				camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 3000);
				camera.position.set(0, 0, 600);
// 				camera.lookAt(0, 0, 0);

				// orbit controls
				orbit = new THREE.OrbitControls(camera, renderer.domElement);
				orbit.update();
				orbit.addEventListener('change', render);

				// transform controls, turn off orbit if dragging?
				control = new THREE.TransformControls(camera, renderer.domElement);
				control.addEventListener('change', render);
				control.addEventListener('dragging-changed', function (event) {
					orbit.enabled = ! event.value;
					});

				// set transform controls to rotate
				control.setMode( "rotate" );

				// attach the transform controls to the object, then add controls to scene
				control.attach(objMesh);
				scene.add(control);

				// standard resize handler
				window.addEventListener( 'resize', onWindowResize, false );
        window.addEventListener( 'deviceorientation', callback, false );

				}
     $("button").click(function(){
         $.ajax({
             type: "POST",
             url: '{{ form_fields["post_url"] }}',
             data: {alpha_beta_gamma:JSON.stringify(values)
             },
             success: function() {
                 console.log("POST Successful");
                 console.log('{{ form_fields["next_page"] }}');
                 console.log('{{ form_fields["post_url"] }}');
                 window.location.href = '{{ form_fields["next_page"] }}';
             },
             fail: function(e) {
                 console.log("sending failed, error: " + e);
                 console.log('{{ form_fields["next_page"] }}');
                 console.log('{{ form_fields["post_url"] }}');
             }
         });
         //return false;
     });

			// animation loop
			function animate() {
				requestAnimationFrame(animate);
				render();
				}


			// scene renderer
			function render() {
				var renderTarget, newEnvMap;

				// update the object env map if necessary
				renderTarget = hdrCubeRenderTarget;
				newEnvMap = renderTarget ? renderTarget.texture : null;
				if ( newEnvMap && newEnvMap !== objMesh.material.envMap ) {
					objMesh.material.envMap = newEnvMap;
					objMesh.material.needsUpdate = true;
					}

				// render the scene
				renderer.render(scene, camera);
				}


			// window resize handler
			function onWindowResize() {
				var width = window.innerWidth;
				var height = window.innerHeight;
				camera.aspect = width/height;
				camera.updateProjectionMatrix();
				renderer.setSize(width, height);
				}

     function callback(event){
         values.push({ alpha:event.alpha, beta:event.beta, gamma:event.gamma});
}
    </script>

	</body>
</html>
